ClassPath:  jvm的一个环境变量 ，jvm通过它来找到class文件
      .;%JAVA_Home;其他....
      .; java当前目录下寻找class文件
      其他路径下寻找class文件
      idea这些IDE其实也是通过这种方式去找到所需要的jar包的，我现在之所以能引用到那些加入的maven项目，是因为这些项目在运行的时候会去找maven加入
      依赖的项目，然后就直接引用它。IDE在确保能找到它们的情况下，去帮我们主动的使用这些类。这个方法就好像一个类去引用另一个类的情况，假如我们
      用记事本来编写代码，那我们也可以通过"实例化.方法"去找到一个类，只要你去写了这个类的完整类路径


反射---
   即是jvm在一个项目运行时产生的一类唯一的数据类型（每个类被第一次主动使用时加载的类1.实例化  2.访问静态方法  3.访问静态属性
   4.初始化子类时初始化父类  5.反射 6.main）
   一个Clazz文件包含了一个类的全部结构信息（完整类名、包名、父类、属性、方法）
   获取一个class文件可以通过  类.class   实例化对象.getClass()   Class.forName("类的完整路径名")
   数组的class文件是[l类的完整路径

泛型---
   1.优点是编写一次、万能匹配
   2.一个类是泛型类，那么static方法和属性，泛型的前面要加<T> 才能用
   3.泛型是在编译器将类型强转为合适的类，jvm操作的仍然是Object类，由于int等基本类型不是继承自Object，所以无法用。
     泛型由于在虚拟机层面都是Object，所以不能获取到特定的class
   4.如果泛型中想用继承关系的类需要<? extends Something>
   5.<? super Something>   接收的参数是Something和Something的父类
   6.何时用extend、何时用super    ,如果需要返回Something则extend






























